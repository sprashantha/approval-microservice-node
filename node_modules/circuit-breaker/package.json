{
  "name": "circuit-breaker",
  "version": "0.0.4",
  "author": {
    "name": "Matt Weagle",
    "email": "mweagle@gmail.com"
  },
  "description": "Port of Akka's CircuitBreaker",
  "contributors": [
    {
      "name": "Matt Weagle",
      "email": "mweagle@gmail.com"
    }
  ],
  "main": "./lib/circuit-breaker.js",
  "keywords": [
    "distributed",
    "patterns"
  ],
  "dependencies": {},
  "analyze": false,
  "devDependencies": {
    "mocha": "1.17.1"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mweagle/circuit-breaker.git"
  },
  "license": "MIT",
  "engines": {
    "node": ">=0.10.0"
  },
  "readme": "circuit-breaker\n====================\n\nWhat Is It\n===\n\nThis is a port of\n[Akka's Circuit Breaker](https://github.com/akka/akka/blob/master/akka-actor/src/main/scala/akka/pattern/CircuitBreaker.scala)\nto [Node.js](http://nodejs.org).  When properly configured it can aid in [preventing cascading failures\nin distributed systems](http://doc.akka.io/docs/akka/snapshot/common/circuitbreaker.html).\n\nWhy Use It\n===\n\nBecause you have distributed resources and you would prefer not to self-inflict a\n[DOS-style attack](http://en.wikipedia.org/wiki/Denial-of-service_attack) while\nminimizing call latency in the presence of errors.  See also the\n[Netflix post](http://techblog.netflix.com/2011/12/making-netflix-api-more-resilient.html)\non creating resilient systems.\n\nHow to Use It\n===\n\n1. Install: `npm install circuit-breaker`\n2. Determine the configuration settings.  The documentation below is largely\ncopied from the [Akka source](https://github.com/akka/akka/blob/master/akka-actor/src/main/scala/akka/pattern/CircuitBreaker.scala#L78).\n    1. `max_failures`:  The maximum error count to accumulate\n                      before the gated function is assumed to have tripped\n                      the breaker into the *OPEN* state.  NOTE:  An error is indicated\n                      by invoking the `callback(e, result)` with a \"truthy\"\n                      Error value.\n    2. `call_timeout_ms`: Duration (in MS) that should be used to limit the execution time\n                        of a gated function.  A function that takes longer than this\n                        upper bound is assumed to have failed.\n    3. `reset_timeout_ms`: Duration (in MS) that must expire for a tripped breaker\n                        to transition to the *HALF-OPEN* state.  When a breaker enters\n                        the *HALF-OPEN* state, the next call will be attempted, but\n                        subsequent calls will fail fast until the results of the\n                        allowed function are evaluated.  If the allowed function\n                        succeeds, the failure count is set to zero and the breaker\n                        enters the *CLOSED* state.  If it fails, the breaker enters the\n                        *OPEN* state and the reset timer is restarted.\n\n3. Reference It\n\n  The circuit-breaker wraps either free functions or logically-related\n  functions defined on a single Object.  The wrapped function(s) are aliased\n  by the breaker so existing code transparently benefits from the\n  fail-fast behavior.\n\n  1. For a \"standalone\" function\n\n      ```javascript\n        var source_function = function(callback)\n        {\n          setImmediate(callback, null, null);\n        };\n        var gated_function = circuit_breaker.new_circuit_breaker(source_function,\n                                                                  5 /* max_failures */,\n                                                                  10 /* call_timeout_ms */,\n                                                                  10 /* reset_timeout_ms */);\n        gated_function(function (error, result) {\n          console.log(\"Whee!\");\n        });\n      ```\n\n  2. For a set of semantically related functions attached to an Object (*eg*,\n     a set of methods that correspond to an *RPC*-ish HTTP API exposed by a single\n     host) :\n\n      ```javascript\n        var RemoteServiceAPI = function()\n        {\n          this.do_it = function(input, callback)\n          {\n            ...\n          };\n          this.do_it_smarter = function(some, value, callback)\n          {\n            ...\n          };\n          this.copyright = function(lawyers, callback)\n          {\n            ...\n          };\n        };\n        // Wrapping an 'API object' in a circuit breaker\n        // makes all the source functions available on the\n        // circuit-breaker instance.  All aliased functions\n        // share the same circuit-breaker instance\n        // so their aggregated behavior contributes to a\n        // single error count.\n        var gated_api_adapter = circuit_breaker.new_circuit_breaker(new RemoteServiceAPI(),\n                                                                    5 /* max_failures */,\n                                                                    10 /* call_timeout_ms */,\n                                                                    10 /* reset_timeout_ms */);\n        gated_api_adapter.do_it('with some value', function (error, callback) {\n          ...\n        });\n      ```\n\nError Cases\n===\nThere are two states that the circuit-breaker Errors-out on and interrupts the\nnormal control flow:\n  - Breaker is in the *OPEN* state: The breaker has been tripped and all\n                                    function calls made while in this state will\n                                    fail-fast with a `CircuitBreakerError` instance\n                                    provided to the callback.\n  - Function timeout: A given call has timed out and the callback is invoked\n              with a `TimeoutError` instance.\n              *NOTE*: any results (or Errors) returned after a `TimeoutError` has\n              been raised will be discarded.\n\nSounds Great - What's the Catch?\n===\n\nThe circuit-breaker depends on (asynchronous-only, CPS-style) functions whose\n*last* argument is a callback of the form: `callback(error, result)`.  In order\nto tap the call sequence the circuit-breaker assumes that the last function argument\nis a callback function whose inputs can be used to update the breaker state.  Once the\ncircuit-breaker state has been updated with the tapped results, the `(error, result)`\nvalues are passed to the original callback function.\n\nTherefore, \"circuit-gatable\" signatures include:\n\n```javascript\nvar zero_args = function(callback) {...};\nvar one_arg = function(input1, callback) {...};\nvar two_args = function(input1, input2, callback) {...};\n// turtles...\n```\n\nBut, if your function parameters are ordered as in:\n\n```javascript\nvar breaker_needed = function(callback, input1, input2)\n```\n\nYou're on your own.\n\nTODOs\n===\n* Allow alternative function signatures\n* Use a [phi-accrual-detector](https://github.com/mweagle/phi-accrual-detector) instead\n  of a simple error count\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mweagle/circuit-breaker/issues"
  },
  "homepage": "https://github.com/mweagle/circuit-breaker",
  "_id": "circuit-breaker@0.0.4",
  "dist": {
    "shasum": "95fb51eeac54871dd786474d0ff04cda16caa9b8"
  },
  "_from": "circuit-breaker@",
  "_resolved": "https://registry.npmjs.org/circuit-breaker/-/circuit-breaker-0.0.4.tgz"
}
